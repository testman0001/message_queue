// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: coord_grpc.proto

/*
	Package coordgrpc is a generated protocol buffer package.

	It is generated from these files:
		coord_grpc.proto

	It has these top-level messages:
		CoordErr
		RpcTopicData
		MsgQueueInterval
		ChannelConsumerOffset
		CommitLogData
		NsqdMessage
		RpcChannelOffsetArg
		RpcPutMessage
		RpcPutMessages
		PullCommitLogsReq
		PullCommitLogsRsp
*/
package coordgrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CoordErr struct {
	ErrMsg  string `protobuf:"bytes,1,opt,name=err_msg,json=errMsg,proto3" json:"err_msg,omitempty"`
	ErrCode int32  `protobuf:"varint,2,opt,name=err_code,json=errCode,proto3" json:"err_code,omitempty"`
	ErrType int32  `protobuf:"varint,3,opt,name=err_type,json=errType,proto3" json:"err_type,omitempty"`
}

func (m *CoordErr) Reset()                    { *m = CoordErr{} }
func (m *CoordErr) String() string            { return proto.CompactTextString(m) }
func (*CoordErr) ProtoMessage()               {}
func (*CoordErr) Descriptor() ([]byte, []int) { return fileDescriptorCoordGrpc, []int{0} }

type RpcTopicData struct {
	TopicName               string `protobuf:"bytes,1,opt,name=topic_name,json=topicName,proto3" json:"topic_name,omitempty"`
	TopicPartition          int32  `protobuf:"varint,2,opt,name=topic_partition,json=topicPartition,proto3" json:"topic_partition,omitempty"`
	Epoch                   int64  `protobuf:"varint,3,opt,name=epoch,proto3" json:"epoch,omitempty"`
	TopicWriteEpoch         int64  `protobuf:"varint,4,opt,name=topic_write_epoch,json=topicWriteEpoch,proto3" json:"topic_write_epoch,omitempty"`
	TopicLeaderSessionEpoch int64  `protobuf:"varint,5,opt,name=topic_leader_session_epoch,json=topicLeaderSessionEpoch,proto3" json:"topic_leader_session_epoch,omitempty"`
	TopicLeaderSession      string `protobuf:"bytes,6,opt,name=topic_leader_session,json=topicLeaderSession,proto3" json:"topic_leader_session,omitempty"`
	TopicLeader             string `protobuf:"bytes,7,opt,name=topic_leader,json=topicLeader,proto3" json:"topic_leader,omitempty"`
}

func (m *RpcTopicData) Reset()                    { *m = RpcTopicData{} }
func (m *RpcTopicData) String() string            { return proto.CompactTextString(m) }
func (*RpcTopicData) ProtoMessage()               {}
func (*RpcTopicData) Descriptor() ([]byte, []int) { return fileDescriptorCoordGrpc, []int{1} }

type MsgQueueInterval struct {
	Start  int64  `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End    int64  `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	EndCnt uint64 `protobuf:"varint,3,opt,name=end_cnt,json=endCnt,proto3" json:"end_cnt,omitempty"`
}

func (m *MsgQueueInterval) Reset()                    { *m = MsgQueueInterval{} }
func (m *MsgQueueInterval) String() string            { return proto.CompactTextString(m) }
func (*MsgQueueInterval) ProtoMessage()               {}
func (*MsgQueueInterval) Descriptor() ([]byte, []int) { return fileDescriptorCoordGrpc, []int{2} }

type ChannelConsumerOffset struct {
	Voffset             int64              `protobuf:"varint,1,opt,name=voffset,proto3" json:"voffset,omitempty"`
	Flush               bool               `protobuf:"varint,2,opt,name=flush,proto3" json:"flush,omitempty"`
	AllowBackward       bool               `protobuf:"varint,3,opt,name=allow_backward,json=allowBackward,proto3" json:"allow_backward,omitempty"`
	Vcnt                int64              `protobuf:"varint,4,opt,name=vcnt,proto3" json:"vcnt,omitempty"`
	NeedUpdateConfirmed bool               `protobuf:"varint,5,opt,name=need_update_confirmed,json=needUpdateConfirmed,proto3" json:"need_update_confirmed,omitempty"`
	ConfirmedIntervals  []MsgQueueInterval `protobuf:"bytes,6,rep,name=confirmed_intervals,json=confirmedIntervals" json:"confirmed_intervals"`
}

func (m *ChannelConsumerOffset) Reset()                    { *m = ChannelConsumerOffset{} }
func (m *ChannelConsumerOffset) String() string            { return proto.CompactTextString(m) }
func (*ChannelConsumerOffset) ProtoMessage()               {}
func (*ChannelConsumerOffset) Descriptor() ([]byte, []int) { return fileDescriptorCoordGrpc, []int{3} }

type CommitLogData struct {
	LogID        int64 `protobuf:"varint,1,opt,name=logID,proto3" json:"logID,omitempty"`
	Epoch        int64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	LastMsgLogID int64 `protobuf:"varint,3,opt,name=last_msg_logID,json=lastMsgLogID,proto3" json:"last_msg_logID,omitempty"`
	MsgOffset    int64 `protobuf:"varint,4,opt,name=msg_offset,json=msgOffset,proto3" json:"msg_offset,omitempty"`
	MsgSize      int32 `protobuf:"varint,5,opt,name=msg_size,json=msgSize,proto3" json:"msg_size,omitempty"`
	MsgCnt       int64 `protobuf:"varint,6,opt,name=msg_cnt,json=msgCnt,proto3" json:"msg_cnt,omitempty"`
	MsgNum       int32 `protobuf:"varint,7,opt,name=msg_num,json=msgNum,proto3" json:"msg_num,omitempty"`
}

func (m *CommitLogData) Reset()                    { *m = CommitLogData{} }
func (m *CommitLogData) String() string            { return proto.CompactTextString(m) }
func (*CommitLogData) ProtoMessage()               {}
func (*CommitLogData) Descriptor() ([]byte, []int) { return fileDescriptorCoordGrpc, []int{4} }

type NsqdMessage struct {
	ID        uint64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Trace_ID  uint64 `protobuf:"varint,2,opt,name=trace_ID,json=traceID,proto3" json:"trace_ID,omitempty"`
	Body      []byte `protobuf:"bytes,3,opt,name=body,proto3" json:"body,omitempty"`
	Timestamp int64  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Attemps   uint32 `protobuf:"varint,5,opt,name=attemps,proto3" json:"attemps,omitempty"`
}

func (m *NsqdMessage) Reset()                    { *m = NsqdMessage{} }
func (m *NsqdMessage) String() string            { return proto.CompactTextString(m) }
func (*NsqdMessage) ProtoMessage()               {}
func (*NsqdMessage) Descriptor() ([]byte, []int) { return fileDescriptorCoordGrpc, []int{5} }

type RpcChannelOffsetArg struct {
	TopicData     *RpcTopicData          `protobuf:"bytes,1,opt,name=topic_data,json=topicData" json:"topic_data,omitempty"`
	Channel       string                 `protobuf:"bytes,2,opt,name=channel,proto3" json:"channel,omitempty"`
	ChannelOffset *ChannelConsumerOffset `protobuf:"bytes,3,opt,name=channel_offset,json=channelOffset" json:"channel_offset,omitempty"`
}

func (m *RpcChannelOffsetArg) Reset()                    { *m = RpcChannelOffsetArg{} }
func (m *RpcChannelOffsetArg) String() string            { return proto.CompactTextString(m) }
func (*RpcChannelOffsetArg) ProtoMessage()               {}
func (*RpcChannelOffsetArg) Descriptor() ([]byte, []int) { return fileDescriptorCoordGrpc, []int{6} }

type RpcPutMessage struct {
	TopicData       *RpcTopicData  `protobuf:"bytes,1,opt,name=topic_data,json=topicData" json:"topic_data,omitempty"`
	LogData         *CommitLogData `protobuf:"bytes,2,opt,name=log_data,json=logData" json:"log_data,omitempty"`
	TopicMessage    *NsqdMessage   `protobuf:"bytes,3,opt,name=topic_message,json=topicMessage" json:"topic_message,omitempty"`
	TopicRawMessage []byte         `protobuf:"bytes,4,opt,name=topic_raw_message,json=topicRawMessage,proto3" json:"topic_raw_message,omitempty"`
}

func (m *RpcPutMessage) Reset()                    { *m = RpcPutMessage{} }
func (m *RpcPutMessage) String() string            { return proto.CompactTextString(m) }
func (*RpcPutMessage) ProtoMessage()               {}
func (*RpcPutMessage) Descriptor() ([]byte, []int) { return fileDescriptorCoordGrpc, []int{7} }

type RpcPutMessages struct {
	TopicData       *RpcTopicData  `protobuf:"bytes,1,opt,name=topic_data,json=topicData" json:"topic_data,omitempty"`
	LogData         *CommitLogData `protobuf:"bytes,2,opt,name=log_data,json=logData" json:"log_data,omitempty"`
	TopicMessage    []*NsqdMessage `protobuf:"bytes,3,rep,name=topic_message,json=topicMessage" json:"topic_message,omitempty"`
	TopicRawMessage []byte         `protobuf:"bytes,4,opt,name=topic_raw_message,json=topicRawMessage,proto3" json:"topic_raw_message,omitempty"`
}

func (m *RpcPutMessages) Reset()                    { *m = RpcPutMessages{} }
func (m *RpcPutMessages) String() string            { return proto.CompactTextString(m) }
func (*RpcPutMessages) ProtoMessage()               {}
func (*RpcPutMessages) Descriptor() ([]byte, []int) { return fileDescriptorCoordGrpc, []int{8} }

type PullCommitLogsReq struct {
	TopicData        *RpcTopicData `protobuf:"bytes,1,opt,name=topic_data,json=topicData" json:"topic_data,omitempty"`
	StartLogOffset   int64         `protobuf:"varint,2,opt,name=start_log_offset,json=startLogOffset,proto3" json:"start_log_offset,omitempty"`
	LogMaxNum        int32         `protobuf:"varint,3,opt,name=log_max_num,json=logMaxNum,proto3" json:"log_max_num,omitempty"`
	StartIndexCnt    int64         `protobuf:"varint,4,opt,name=start_index_cnt,json=startIndexCnt,proto3" json:"start_index_cnt,omitempty"`
	LogCountNumIndex int64         `protobuf:"varint,5,opt,name=log_count_num_index,json=logCountNumIndex,proto3" json:"log_count_num_index,omitempty"`
	UseCountIndex    bool          `protobuf:"varint,6,opt,name=use_count_index,json=useCountIndex,proto3" json:"use_count_index,omitempty"`
}

func (m *PullCommitLogsReq) Reset()                    { *m = PullCommitLogsReq{} }
func (m *PullCommitLogsReq) String() string            { return proto.CompactTextString(m) }
func (*PullCommitLogsReq) ProtoMessage()               {}
func (*PullCommitLogsReq) Descriptor() ([]byte, []int) { return fileDescriptorCoordGrpc, []int{9} }

type PullCommitLogsRsp struct {
	Logs     []CommitLogData `protobuf:"bytes,1,rep,name=logs" json:"logs"`
	DataList [][]byte        `protobuf:"bytes,2,rep,name=data_list,json=dataList" json:"data_list,omitempty"`
}

func (m *PullCommitLogsRsp) Reset()                    { *m = PullCommitLogsRsp{} }
func (m *PullCommitLogsRsp) String() string            { return proto.CompactTextString(m) }
func (*PullCommitLogsRsp) ProtoMessage()               {}
func (*PullCommitLogsRsp) Descriptor() ([]byte, []int) { return fileDescriptorCoordGrpc, []int{10} }

func init() {
	proto.RegisterType((*CoordErr)(nil), "coordgrpc.CoordErr")
	proto.RegisterType((*RpcTopicData)(nil), "coordgrpc.RpcTopicData")
	proto.RegisterType((*MsgQueueInterval)(nil), "coordgrpc.MsgQueueInterval")
	proto.RegisterType((*ChannelConsumerOffset)(nil), "coordgrpc.ChannelConsumerOffset")
	proto.RegisterType((*CommitLogData)(nil), "coordgrpc.CommitLogData")
	proto.RegisterType((*NsqdMessage)(nil), "coordgrpc.NsqdMessage")
	proto.RegisterType((*RpcChannelOffsetArg)(nil), "coordgrpc.RpcChannelOffsetArg")
	proto.RegisterType((*RpcPutMessage)(nil), "coordgrpc.RpcPutMessage")
	proto.RegisterType((*RpcPutMessages)(nil), "coordgrpc.RpcPutMessages")
	proto.RegisterType((*PullCommitLogsReq)(nil), "coordgrpc.PullCommitLogsReq")
	proto.RegisterType((*PullCommitLogsRsp)(nil), "coordgrpc.PullCommitLogsRsp")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NsqdCoordRpcV2 service

type NsqdCoordRpcV2Client interface {
	UpdateChannelOffset(ctx context.Context, in *RpcChannelOffsetArg, opts ...grpc.CallOption) (*CoordErr, error)
	PutMessage(ctx context.Context, in *RpcPutMessage, opts ...grpc.CallOption) (*CoordErr, error)
	PutMessages(ctx context.Context, in *RpcPutMessages, opts ...grpc.CallOption) (*CoordErr, error)
	PullCommitLogsAndData(ctx context.Context, in *PullCommitLogsReq, opts ...grpc.CallOption) (*PullCommitLogsRsp, error)
	PullDelayedQueueCommitLogsAndData(ctx context.Context, in *PullCommitLogsReq, opts ...grpc.CallOption) (*PullCommitLogsRsp, error)
}

type nsqdCoordRpcV2Client struct {
	cc *grpc.ClientConn
}

func NewNsqdCoordRpcV2Client(cc *grpc.ClientConn) NsqdCoordRpcV2Client {
	return &nsqdCoordRpcV2Client{cc}
}

func (c *nsqdCoordRpcV2Client) UpdateChannelOffset(ctx context.Context, in *RpcChannelOffsetArg, opts ...grpc.CallOption) (*CoordErr, error) {
	out := new(CoordErr)
	err := grpc.Invoke(ctx, "/coordgrpc.NsqdCoordRpcV2/UpdateChannelOffset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nsqdCoordRpcV2Client) PutMessage(ctx context.Context, in *RpcPutMessage, opts ...grpc.CallOption) (*CoordErr, error) {
	out := new(CoordErr)
	err := grpc.Invoke(ctx, "/coordgrpc.NsqdCoordRpcV2/PutMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nsqdCoordRpcV2Client) PutMessages(ctx context.Context, in *RpcPutMessages, opts ...grpc.CallOption) (*CoordErr, error) {
	out := new(CoordErr)
	err := grpc.Invoke(ctx, "/coordgrpc.NsqdCoordRpcV2/PutMessages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nsqdCoordRpcV2Client) PullCommitLogsAndData(ctx context.Context, in *PullCommitLogsReq, opts ...grpc.CallOption) (*PullCommitLogsRsp, error) {
	out := new(PullCommitLogsRsp)
	err := grpc.Invoke(ctx, "/coordgrpc.NsqdCoordRpcV2/PullCommitLogsAndData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nsqdCoordRpcV2Client) PullDelayedQueueCommitLogsAndData(ctx context.Context, in *PullCommitLogsReq, opts ...grpc.CallOption) (*PullCommitLogsRsp, error) {
	out := new(PullCommitLogsRsp)
	err := grpc.Invoke(ctx, "/coordgrpc.NsqdCoordRpcV2/PullDelayedQueueCommitLogsAndData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NsqdCoordRpcV2 service

type NsqdCoordRpcV2Server interface {
	UpdateChannelOffset(context.Context, *RpcChannelOffsetArg) (*CoordErr, error)
	PutMessage(context.Context, *RpcPutMessage) (*CoordErr, error)
	PutMessages(context.Context, *RpcPutMessages) (*CoordErr, error)
	PullCommitLogsAndData(context.Context, *PullCommitLogsReq) (*PullCommitLogsRsp, error)
	PullDelayedQueueCommitLogsAndData(context.Context, *PullCommitLogsReq) (*PullCommitLogsRsp, error)
}

func RegisterNsqdCoordRpcV2Server(s *grpc.Server, srv NsqdCoordRpcV2Server) {
	s.RegisterService(&_NsqdCoordRpcV2_serviceDesc, srv)
}

func _NsqdCoordRpcV2_UpdateChannelOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcChannelOffsetArg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsqdCoordRpcV2Server).UpdateChannelOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coordgrpc.NsqdCoordRpcV2/UpdateChannelOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsqdCoordRpcV2Server).UpdateChannelOffset(ctx, req.(*RpcChannelOffsetArg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NsqdCoordRpcV2_PutMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcPutMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsqdCoordRpcV2Server).PutMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coordgrpc.NsqdCoordRpcV2/PutMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsqdCoordRpcV2Server).PutMessage(ctx, req.(*RpcPutMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _NsqdCoordRpcV2_PutMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcPutMessages)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsqdCoordRpcV2Server).PutMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coordgrpc.NsqdCoordRpcV2/PutMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsqdCoordRpcV2Server).PutMessages(ctx, req.(*RpcPutMessages))
	}
	return interceptor(ctx, in, info, handler)
}

func _NsqdCoordRpcV2_PullCommitLogsAndData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullCommitLogsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsqdCoordRpcV2Server).PullCommitLogsAndData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coordgrpc.NsqdCoordRpcV2/PullCommitLogsAndData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsqdCoordRpcV2Server).PullCommitLogsAndData(ctx, req.(*PullCommitLogsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NsqdCoordRpcV2_PullDelayedQueueCommitLogsAndData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullCommitLogsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsqdCoordRpcV2Server).PullDelayedQueueCommitLogsAndData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coordgrpc.NsqdCoordRpcV2/PullDelayedQueueCommitLogsAndData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsqdCoordRpcV2Server).PullDelayedQueueCommitLogsAndData(ctx, req.(*PullCommitLogsReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _NsqdCoordRpcV2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "coordgrpc.NsqdCoordRpcV2",
	HandlerType: (*NsqdCoordRpcV2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateChannelOffset",
			Handler:    _NsqdCoordRpcV2_UpdateChannelOffset_Handler,
		},
		{
			MethodName: "PutMessage",
			Handler:    _NsqdCoordRpcV2_PutMessage_Handler,
		},
		{
			MethodName: "PutMessages",
			Handler:    _NsqdCoordRpcV2_PutMessages_Handler,
		},
		{
			MethodName: "PullCommitLogsAndData",
			Handler:    _NsqdCoordRpcV2_PullCommitLogsAndData_Handler,
		},
		{
			MethodName: "PullDelayedQueueCommitLogsAndData",
			Handler:    _NsqdCoordRpcV2_PullDelayedQueueCommitLogsAndData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "coord_grpc.proto",
}

func (m *CoordErr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoordErr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ErrMsg) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(len(m.ErrMsg)))
		i += copy(dAtA[i:], m.ErrMsg)
	}
	if m.ErrCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.ErrCode))
	}
	if m.ErrType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.ErrType))
	}
	return i, nil
}

func (m *RpcTopicData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcTopicData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TopicName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(len(m.TopicName)))
		i += copy(dAtA[i:], m.TopicName)
	}
	if m.TopicPartition != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.TopicPartition))
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.Epoch))
	}
	if m.TopicWriteEpoch != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.TopicWriteEpoch))
	}
	if m.TopicLeaderSessionEpoch != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.TopicLeaderSessionEpoch))
	}
	if len(m.TopicLeaderSession) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(len(m.TopicLeaderSession)))
		i += copy(dAtA[i:], m.TopicLeaderSession)
	}
	if len(m.TopicLeader) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(len(m.TopicLeader)))
		i += copy(dAtA[i:], m.TopicLeader)
	}
	return i, nil
}

func (m *MsgQueueInterval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgQueueInterval) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.End))
	}
	if m.EndCnt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.EndCnt))
	}
	return i, nil
}

func (m *ChannelConsumerOffset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelConsumerOffset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Voffset != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.Voffset))
	}
	if m.Flush {
		dAtA[i] = 0x10
		i++
		if m.Flush {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AllowBackward {
		dAtA[i] = 0x18
		i++
		if m.AllowBackward {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Vcnt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.Vcnt))
	}
	if m.NeedUpdateConfirmed {
		dAtA[i] = 0x28
		i++
		if m.NeedUpdateConfirmed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ConfirmedIntervals) > 0 {
		for _, msg := range m.ConfirmedIntervals {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCoordGrpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CommitLogData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitLogData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LogID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.LogID))
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.Epoch))
	}
	if m.LastMsgLogID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.LastMsgLogID))
	}
	if m.MsgOffset != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.MsgOffset))
	}
	if m.MsgSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.MsgSize))
	}
	if m.MsgCnt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.MsgCnt))
	}
	if m.MsgNum != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.MsgNum))
	}
	return i, nil
}

func (m *NsqdMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NsqdMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.ID))
	}
	if m.Trace_ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.Trace_ID))
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.Timestamp))
	}
	if m.Attemps != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.Attemps))
	}
	return i, nil
}

func (m *RpcChannelOffsetArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcChannelOffsetArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicData != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.TopicData.Size()))
		n1, err := m.TopicData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.ChannelOffset != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.ChannelOffset.Size()))
		n2, err := m.ChannelOffset.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *RpcPutMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcPutMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicData != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.TopicData.Size()))
		n3, err := m.TopicData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.LogData != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.LogData.Size()))
		n4, err := m.LogData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.TopicMessage != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.TopicMessage.Size()))
		n5, err := m.TopicMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.TopicRawMessage) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(len(m.TopicRawMessage)))
		i += copy(dAtA[i:], m.TopicRawMessage)
	}
	return i, nil
}

func (m *RpcPutMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcPutMessages) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicData != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.TopicData.Size()))
		n6, err := m.TopicData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.LogData != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.LogData.Size()))
		n7, err := m.LogData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.TopicMessage) > 0 {
		for _, msg := range m.TopicMessage {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCoordGrpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TopicRawMessage) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(len(m.TopicRawMessage)))
		i += copy(dAtA[i:], m.TopicRawMessage)
	}
	return i, nil
}

func (m *PullCommitLogsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PullCommitLogsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicData != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.TopicData.Size()))
		n8, err := m.TopicData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.StartLogOffset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.StartLogOffset))
	}
	if m.LogMaxNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.LogMaxNum))
	}
	if m.StartIndexCnt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.StartIndexCnt))
	}
	if m.LogCountNumIndex != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCoordGrpc(dAtA, i, uint64(m.LogCountNumIndex))
	}
	if m.UseCountIndex {
		dAtA[i] = 0x30
		i++
		if m.UseCountIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PullCommitLogsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PullCommitLogsRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for _, msg := range m.Logs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCoordGrpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DataList) > 0 {
		for _, b := range m.DataList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCoordGrpc(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func encodeVarintCoordGrpc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CoordErr) Size() (n int) {
	var l int
	_ = l
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	if m.ErrCode != 0 {
		n += 1 + sovCoordGrpc(uint64(m.ErrCode))
	}
	if m.ErrType != 0 {
		n += 1 + sovCoordGrpc(uint64(m.ErrType))
	}
	return n
}

func (m *RpcTopicData) Size() (n int) {
	var l int
	_ = l
	l = len(m.TopicName)
	if l > 0 {
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	if m.TopicPartition != 0 {
		n += 1 + sovCoordGrpc(uint64(m.TopicPartition))
	}
	if m.Epoch != 0 {
		n += 1 + sovCoordGrpc(uint64(m.Epoch))
	}
	if m.TopicWriteEpoch != 0 {
		n += 1 + sovCoordGrpc(uint64(m.TopicWriteEpoch))
	}
	if m.TopicLeaderSessionEpoch != 0 {
		n += 1 + sovCoordGrpc(uint64(m.TopicLeaderSessionEpoch))
	}
	l = len(m.TopicLeaderSession)
	if l > 0 {
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	l = len(m.TopicLeader)
	if l > 0 {
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	return n
}

func (m *MsgQueueInterval) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovCoordGrpc(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovCoordGrpc(uint64(m.End))
	}
	if m.EndCnt != 0 {
		n += 1 + sovCoordGrpc(uint64(m.EndCnt))
	}
	return n
}

func (m *ChannelConsumerOffset) Size() (n int) {
	var l int
	_ = l
	if m.Voffset != 0 {
		n += 1 + sovCoordGrpc(uint64(m.Voffset))
	}
	if m.Flush {
		n += 2
	}
	if m.AllowBackward {
		n += 2
	}
	if m.Vcnt != 0 {
		n += 1 + sovCoordGrpc(uint64(m.Vcnt))
	}
	if m.NeedUpdateConfirmed {
		n += 2
	}
	if len(m.ConfirmedIntervals) > 0 {
		for _, e := range m.ConfirmedIntervals {
			l = e.Size()
			n += 1 + l + sovCoordGrpc(uint64(l))
		}
	}
	return n
}

func (m *CommitLogData) Size() (n int) {
	var l int
	_ = l
	if m.LogID != 0 {
		n += 1 + sovCoordGrpc(uint64(m.LogID))
	}
	if m.Epoch != 0 {
		n += 1 + sovCoordGrpc(uint64(m.Epoch))
	}
	if m.LastMsgLogID != 0 {
		n += 1 + sovCoordGrpc(uint64(m.LastMsgLogID))
	}
	if m.MsgOffset != 0 {
		n += 1 + sovCoordGrpc(uint64(m.MsgOffset))
	}
	if m.MsgSize != 0 {
		n += 1 + sovCoordGrpc(uint64(m.MsgSize))
	}
	if m.MsgCnt != 0 {
		n += 1 + sovCoordGrpc(uint64(m.MsgCnt))
	}
	if m.MsgNum != 0 {
		n += 1 + sovCoordGrpc(uint64(m.MsgNum))
	}
	return n
}

func (m *NsqdMessage) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovCoordGrpc(uint64(m.ID))
	}
	if m.Trace_ID != 0 {
		n += 1 + sovCoordGrpc(uint64(m.Trace_ID))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovCoordGrpc(uint64(m.Timestamp))
	}
	if m.Attemps != 0 {
		n += 1 + sovCoordGrpc(uint64(m.Attemps))
	}
	return n
}

func (m *RpcChannelOffsetArg) Size() (n int) {
	var l int
	_ = l
	if m.TopicData != nil {
		l = m.TopicData.Size()
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	if m.ChannelOffset != nil {
		l = m.ChannelOffset.Size()
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	return n
}

func (m *RpcPutMessage) Size() (n int) {
	var l int
	_ = l
	if m.TopicData != nil {
		l = m.TopicData.Size()
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	if m.LogData != nil {
		l = m.LogData.Size()
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	if m.TopicMessage != nil {
		l = m.TopicMessage.Size()
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	l = len(m.TopicRawMessage)
	if l > 0 {
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	return n
}

func (m *RpcPutMessages) Size() (n int) {
	var l int
	_ = l
	if m.TopicData != nil {
		l = m.TopicData.Size()
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	if m.LogData != nil {
		l = m.LogData.Size()
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	if len(m.TopicMessage) > 0 {
		for _, e := range m.TopicMessage {
			l = e.Size()
			n += 1 + l + sovCoordGrpc(uint64(l))
		}
	}
	l = len(m.TopicRawMessage)
	if l > 0 {
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	return n
}

func (m *PullCommitLogsReq) Size() (n int) {
	var l int
	_ = l
	if m.TopicData != nil {
		l = m.TopicData.Size()
		n += 1 + l + sovCoordGrpc(uint64(l))
	}
	if m.StartLogOffset != 0 {
		n += 1 + sovCoordGrpc(uint64(m.StartLogOffset))
	}
	if m.LogMaxNum != 0 {
		n += 1 + sovCoordGrpc(uint64(m.LogMaxNum))
	}
	if m.StartIndexCnt != 0 {
		n += 1 + sovCoordGrpc(uint64(m.StartIndexCnt))
	}
	if m.LogCountNumIndex != 0 {
		n += 1 + sovCoordGrpc(uint64(m.LogCountNumIndex))
	}
	if m.UseCountIndex {
		n += 2
	}
	return n
}

func (m *PullCommitLogsRsp) Size() (n int) {
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for _, e := range m.Logs {
			l = e.Size()
			n += 1 + l + sovCoordGrpc(uint64(l))
		}
	}
	if len(m.DataList) > 0 {
		for _, b := range m.DataList {
			l = len(b)
			n += 1 + l + sovCoordGrpc(uint64(l))
		}
	}
	return n
}

func sovCoordGrpc(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCoordGrpc(x uint64) (n int) {
	return sovCoordGrpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CoordErr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoordErr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoordErr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrType", wireType)
			}
			m.ErrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcTopicData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcTopicData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcTopicData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicPartition", wireType)
			}
			m.TopicPartition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicPartition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicWriteEpoch", wireType)
			}
			m.TopicWriteEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicWriteEpoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicLeaderSessionEpoch", wireType)
			}
			m.TopicLeaderSessionEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicLeaderSessionEpoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicLeaderSession", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicLeaderSession = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicLeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicLeader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgQueueInterval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgQueueInterval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgQueueInterval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndCnt", wireType)
			}
			m.EndCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndCnt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelConsumerOffset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelConsumerOffset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelConsumerOffset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voffset", wireType)
			}
			m.Voffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Voffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flush", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flush = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowBackward", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowBackward = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcnt", wireType)
			}
			m.Vcnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vcnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedUpdateConfirmed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedUpdateConfirmed = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmedIntervals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfirmedIntervals = append(m.ConfirmedIntervals, MsgQueueInterval{})
			if err := m.ConfirmedIntervals[len(m.ConfirmedIntervals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitLogData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitLogData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitLogData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogID", wireType)
			}
			m.LogID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMsgLogID", wireType)
			}
			m.LastMsgLogID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMsgLogID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgOffset", wireType)
			}
			m.MsgOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgOffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSize", wireType)
			}
			m.MsgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgCnt", wireType)
			}
			m.MsgCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgCnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgNum", wireType)
			}
			m.MsgNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NsqdMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NsqdMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NsqdMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trace_ID", wireType)
			}
			m.Trace_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Trace_ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attemps", wireType)
			}
			m.Attemps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attemps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoordGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcChannelOffsetArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcChannelOffsetArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcChannelOffsetArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopicData == nil {
				m.TopicData = &RpcTopicData{}
			}
			if err := m.TopicData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelOffset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChannelOffset == nil {
				m.ChannelOffset = &ChannelConsumerOffset{}
			}
			if err := m.ChannelOffset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcPutMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcPutMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcPutMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopicData == nil {
				m.TopicData = &RpcTopicData{}
			}
			if err := m.TopicData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogData == nil {
				m.LogData = &CommitLogData{}
			}
			if err := m.LogData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopicMessage == nil {
				m.TopicMessage = &NsqdMessage{}
			}
			if err := m.TopicMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicRawMessage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicRawMessage = append(m.TopicRawMessage[:0], dAtA[iNdEx:postIndex]...)
			if m.TopicRawMessage == nil {
				m.TopicRawMessage = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcPutMessages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcPutMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcPutMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopicData == nil {
				m.TopicData = &RpcTopicData{}
			}
			if err := m.TopicData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogData == nil {
				m.LogData = &CommitLogData{}
			}
			if err := m.LogData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicMessage = append(m.TopicMessage, &NsqdMessage{})
			if err := m.TopicMessage[len(m.TopicMessage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicRawMessage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicRawMessage = append(m.TopicRawMessage[:0], dAtA[iNdEx:postIndex]...)
			if m.TopicRawMessage == nil {
				m.TopicRawMessage = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PullCommitLogsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PullCommitLogsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PullCommitLogsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopicData == nil {
				m.TopicData = &RpcTopicData{}
			}
			if err := m.TopicData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLogOffset", wireType)
			}
			m.StartLogOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartLogOffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogMaxNum", wireType)
			}
			m.LogMaxNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogMaxNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIndexCnt", wireType)
			}
			m.StartIndexCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIndexCnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogCountNumIndex", wireType)
			}
			m.LogCountNumIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogCountNumIndex |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCountIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseCountIndex = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCoordGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PullCommitLogsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoordGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PullCommitLogsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PullCommitLogsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, CommitLogData{})
			if err := m.Logs[len(m.Logs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataList = append(m.DataList, make([]byte, postIndex-iNdEx))
			copy(m.DataList[len(m.DataList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoordGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoordGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCoordGrpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCoordGrpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoordGrpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCoordGrpc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCoordGrpc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCoordGrpc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCoordGrpc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCoordGrpc   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("coord_grpc.proto", fileDescriptorCoordGrpc) }

var fileDescriptorCoordGrpc = []byte{
	// 1100 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x4f, 0x6f, 0xdc, 0x44,
	0x14, 0x5f, 0xef, 0xff, 0x7d, 0x9b, 0xdd, 0xa6, 0xb3, 0x29, 0x75, 0xd3, 0x76, 0x49, 0x2d, 0xfe,
	0x44, 0x48, 0x14, 0xb4, 0x95, 0xb8, 0x54, 0x08, 0xb5, 0xbb, 0x15, 0x5a, 0x69, 0x13, 0xca, 0xa4,
	0x05, 0x71, 0xb2, 0x26, 0xf6, 0xc4, 0xb1, 0xb0, 0x3d, 0xae, 0x67, 0x9c, 0x3f, 0x3d, 0x73, 0xe2,
	0xcc, 0xa1, 0x9f, 0x81, 0x13, 0x1f, 0x23, 0x17, 0xa4, 0x7e, 0x02, 0x44, 0x83, 0xe0, 0x73, 0xa0,
	0x79, 0x63, 0x6f, 0x9c, 0xa6, 0xe1, 0x50, 0x81, 0xb8, 0xcd, 0xbc, 0xf7, 0x7b, 0xff, 0x7e, 0xef,
	0xcd, 0xb3, 0x61, 0xd5, 0x13, 0x22, 0xf3, 0xdd, 0x20, 0x4b, 0xbd, 0xbb, 0x69, 0x26, 0x94, 0x20,
	0x3d, 0x94, 0x68, 0xc1, 0xfa, 0x5a, 0x20, 0x02, 0x81, 0xd2, 0x4f, 0xf4, 0xc9, 0x00, 0x9c, 0xef,
	0xa0, 0x3b, 0xd5, 0x90, 0x47, 0x59, 0x46, 0xae, 0x43, 0x87, 0x67, 0x99, 0x1b, 0xcb, 0xc0, 0xb6,
	0x36, 0xac, 0xcd, 0x1e, 0x6d, 0xf3, 0x2c, 0xdb, 0x92, 0x01, 0xb9, 0x01, 0x5d, 0xad, 0xf0, 0x84,
	0xcf, 0xed, 0xfa, 0x86, 0xb5, 0xd9, 0xa2, 0x1a, 0x38, 0x15, 0x3e, 0x2f, 0x55, 0xea, 0x38, 0xe5,
	0x76, 0x63, 0xa9, 0x7a, 0x72, 0x9c, 0x72, 0xe7, 0xe7, 0x3a, 0xac, 0xd0, 0xd4, 0x7b, 0x22, 0xd2,
	0xd0, 0x9b, 0x31, 0xc5, 0xc8, 0x6d, 0x00, 0xa5, 0x2f, 0x6e, 0xc2, 0x62, 0x5e, 0x84, 0xe8, 0xa1,
	0x64, 0x9b, 0xc5, 0x9c, 0x7c, 0x08, 0x57, 0x8c, 0x3a, 0x65, 0x99, 0x0a, 0x55, 0x28, 0x92, 0x22,
	0xd8, 0x10, 0xc5, 0x8f, 0x4b, 0x29, 0x59, 0x83, 0x16, 0x4f, 0x85, 0xb7, 0x8f, 0x01, 0x1b, 0xd4,
	0x5c, 0xc8, 0x47, 0x70, 0xd5, 0x98, 0x1f, 0x66, 0xa1, 0xe2, 0xae, 0x41, 0x34, 0x11, 0x61, 0xfc,
	0x7e, 0xab, 0xe5, 0x8f, 0x10, 0x7b, 0x1f, 0xd6, 0x0d, 0x36, 0xe2, 0xcc, 0xe7, 0x99, 0x2b, 0xb9,
	0x94, 0xa1, 0x48, 0x0a, 0xa3, 0x16, 0x1a, 0x5d, 0x47, 0xc4, 0x02, 0x01, 0x3b, 0x46, 0x6f, 0x8c,
	0x3f, 0x85, 0xb5, 0x37, 0x19, 0xdb, 0x6d, 0x2c, 0x88, 0x5c, 0x34, 0x23, 0x77, 0x60, 0xa5, 0x6a,
	0x61, 0x77, 0x10, 0xd9, 0xaf, 0x20, 0x9d, 0x1d, 0x58, 0xdd, 0x92, 0xc1, 0xd7, 0x39, 0xcf, 0xf9,
	0x3c, 0x51, 0x3c, 0x3b, 0x60, 0x91, 0xae, 0x53, 0x2a, 0x96, 0x29, 0xa4, 0xaa, 0x41, 0xcd, 0x85,
	0xac, 0x42, 0x83, 0x27, 0x3e, 0x52, 0xd3, 0xa0, 0xfa, 0x88, 0x7d, 0x4b, 0x7c, 0xd7, 0x4b, 0x14,
	0x32, 0xd2, 0xa4, 0x6d, 0x9e, 0xf8, 0xd3, 0x44, 0x39, 0x3f, 0xd6, 0xe1, 0xda, 0x74, 0x9f, 0x25,
	0x09, 0x8f, 0xa6, 0x22, 0x91, 0x79, 0xcc, 0xb3, 0xaf, 0xf6, 0xf6, 0x24, 0x57, 0xc4, 0x86, 0xce,
	0x81, 0xc0, 0x63, 0xe1, 0xbc, 0xbc, 0xea, 0xa0, 0x7b, 0x51, 0x2e, 0xf7, 0x31, 0x40, 0x97, 0x9a,
	0x0b, 0x79, 0x1f, 0x86, 0x2c, 0x8a, 0xc4, 0xa1, 0xbb, 0xcb, 0xbc, 0xef, 0x0f, 0x59, 0xe6, 0x63,
	0xa4, 0x2e, 0x1d, 0xa0, 0xf4, 0x61, 0x21, 0x24, 0x04, 0x9a, 0x07, 0x3a, 0x0d, 0x43, 0x3b, 0x9e,
	0xc9, 0x04, 0xae, 0x25, 0x9c, 0xfb, 0x6e, 0x9e, 0xfa, 0x4c, 0x71, 0xd7, 0x13, 0xc9, 0x5e, 0x98,
	0xc5, 0xdc, 0x47, 0x9a, 0xbb, 0x74, 0xa4, 0x95, 0x4f, 0x51, 0x37, 0x2d, 0x55, 0x84, 0xc2, 0x68,
	0x89, 0x73, 0xc3, 0x82, 0x0f, 0x69, 0xb7, 0x37, 0x1a, 0x9b, 0xfd, 0xc9, 0xcd, 0xbb, 0xcb, 0xa1,
	0xbe, 0xfb, 0x3a, 0x67, 0x0f, 0x9b, 0x27, 0xbf, 0xbd, 0x5b, 0xa3, 0x64, 0x69, 0x5d, 0x2a, 0xa4,
	0xf3, 0xab, 0x05, 0x83, 0xa9, 0x88, 0xe3, 0x50, 0x2d, 0x44, 0x80, 0xf3, 0xb8, 0x06, 0xad, 0x48,
	0x04, 0xf3, 0x59, 0xc9, 0x2f, 0x5e, 0xce, 0xa6, 0xab, 0x5e, 0x9d, 0xae, 0xf7, 0x60, 0x18, 0x31,
	0xa9, 0xf4, 0xe3, 0x70, 0x8d, 0x91, 0x19, 0xbe, 0x15, 0x2d, 0xdd, 0x92, 0xc1, 0x02, 0x6d, 0x6f,
	0x03, 0x68, 0x40, 0xc1, 0xac, 0x61, 0xa1, 0x17, 0xcb, 0xa0, 0x60, 0xfd, 0x06, 0x74, 0xb5, 0x5a,
	0x86, 0xcf, 0x39, 0x56, 0xdf, 0xa2, 0x9d, 0x58, 0x06, 0x3b, 0xe1, 0x73, 0xae, 0x7b, 0xa8, 0x55,
	0x9a, 0xbc, 0x36, 0x9a, 0xb5, 0x63, 0x19, 0x4c, 0x13, 0x55, 0x2a, 0x92, 0x3c, 0xc6, 0xb1, 0x69,
	0xa1, 0x62, 0x3b, 0x8f, 0x9d, 0x1f, 0x2c, 0xe8, 0x6f, 0xcb, 0x67, 0xfe, 0x16, 0x97, 0x92, 0x05,
	0x9c, 0x0c, 0xa1, 0x5e, 0x94, 0xd2, 0xa4, 0xf5, 0xf9, 0x4c, 0x07, 0x53, 0x19, 0xf3, 0xb8, 0x3b,
	0x9f, 0x61, 0x29, 0x4d, 0xda, 0xc1, 0xfb, 0x7c, 0xa6, 0xdb, 0xb4, 0x2b, 0xfc, 0x63, 0x2c, 0x61,
	0x85, 0xe2, 0x99, 0xdc, 0x82, 0x9e, 0x0a, 0x63, 0x2e, 0x15, 0x8b, 0xd3, 0x32, 0xf3, 0xa5, 0x40,
	0xcf, 0x0b, 0x53, 0x8a, 0xc7, 0xa9, 0xc4, 0xc4, 0x07, 0xb4, 0xbc, 0x3a, 0xbf, 0x58, 0x30, 0xa2,
	0xa9, 0x57, 0x8c, 0x99, 0x29, 0xf4, 0x41, 0x16, 0x90, 0xcf, 0xca, 0xc7, 0xee, 0x33, 0xc5, 0x30,
	0xad, 0xfe, 0xe4, 0x7a, 0xa5, 0x73, 0xd5, 0xcd, 0x50, 0x6c, 0x01, 0x6c, 0x8a, 0x0d, 0x1d, 0xcf,
	0xf8, 0xc2, 0xac, 0x7b, 0xb4, 0xbc, 0x92, 0x2f, 0x61, 0x58, 0x1c, 0x4b, 0x82, 0x1b, 0xe8, 0x75,
	0xa3, 0xe2, 0xf5, 0x8d, 0xd3, 0x4e, 0x07, 0x5e, 0x35, 0x3b, 0xe7, 0x4f, 0x0b, 0x06, 0x34, 0xf5,
	0x1e, 0xe7, 0xaa, 0xe4, 0xee, 0x6d, 0x93, 0xbd, 0x07, 0xdd, 0x48, 0x04, 0xc6, 0xaa, 0x8e, 0x56,
	0x76, 0x35, 0x99, 0xea, 0xb4, 0xd1, 0x4e, 0x54, 0x8c, 0xdd, 0x7d, 0x18, 0x98, 0x60, 0xb1, 0x89,
	0x5e, 0x94, 0xf1, 0x4e, 0xc5, 0xb2, 0xd2, 0x57, 0x6a, 0x56, 0x47, 0x99, 0xe9, 0x72, 0xcb, 0x65,
	0xec, 0x70, 0xe9, 0xa0, 0x89, 0x7d, 0x34, 0x5b, 0x8e, 0xb2, 0xc3, 0x02, 0xeb, 0xfc, 0x65, 0xc1,
	0xf0, 0x5c, 0x9d, 0xf2, 0x7f, 0x2f, 0xb4, 0xf1, 0x9f, 0x14, 0xfa, 0x53, 0x1d, 0xae, 0x3e, 0xce,
	0xa3, 0x68, 0x99, 0x87, 0xa4, 0xfc, 0xd9, 0x5b, 0xd7, 0xba, 0x09, 0xab, 0xb8, 0x69, 0xf5, 0x3b,
	0x2f, 0x27, 0xcd, 0xec, 0x82, 0x21, 0xca, 0x17, 0xa2, 0x7c, 0xcf, 0x63, 0xe8, 0x6b, 0x4c, 0xcc,
	0x8e, 0xf0, 0x7d, 0x9a, 0xef, 0x5f, 0x2f, 0x12, 0xc1, 0x16, 0x3b, 0xda, 0xce, 0x63, 0xf2, 0x01,
	0x5c, 0x31, 0x9e, 0xc2, 0xc4, 0xe7, 0x47, 0xee, 0xd9, 0x66, 0x1c, 0xa0, 0x78, 0xae, 0xa5, 0xfa,
	0x8d, 0x7f, 0x0c, 0x23, 0xed, 0xc7, 0x13, 0x79, 0xa2, 0xb4, 0x27, 0x83, 0x2f, 0xbe, 0x43, 0xab,
	0x91, 0x08, 0xa6, 0x5a, 0xb3, 0x9d, 0xc7, 0x68, 0xa1, 0xdd, 0xe6, 0x92, 0x17, 0x70, 0x03, 0x6d,
	0x9b, 0x6d, 0x9c, 0x4b, 0x8e, 0x50, 0xc4, 0x39, 0xfe, 0x05, 0x56, 0x64, 0x4a, 0x26, 0xd0, 0x8c,
	0x44, 0x20, 0x6d, 0x0b, 0x7b, 0x71, 0x69, 0x17, 0x8b, 0x45, 0x8a, 0x58, 0x72, 0x13, 0x7a, 0x9a,
	0x43, 0x37, 0x0a, 0xa5, 0xa6, 0xa2, 0xb1, 0xb9, 0x42, 0xbb, 0x5a, 0xb0, 0x08, 0xa5, 0x9a, 0xbc,
	0x68, 0xc0, 0x50, 0xb7, 0x11, 0x7f, 0x23, 0x68, 0xea, 0x7d, 0x33, 0x21, 0x0b, 0x18, 0x15, 0x1b,
	0xbd, 0xfa, 0xee, 0xc8, 0xf8, 0x3c, 0xf9, 0xaf, 0xaf, 0x8c, 0xf5, 0xd1, 0xb9, 0x64, 0xcc, 0x4f,
	0x89, 0x53, 0x23, 0x9f, 0x03, 0x54, 0x9e, 0xaa, 0x7d, 0xde, 0xc9, 0x99, 0xe6, 0x32, 0xf3, 0x2f,
	0xa0, 0x5f, 0x7d, 0x01, 0x37, 0x2e, 0xb3, 0x97, 0x97, 0x39, 0x78, 0x0a, 0xd7, 0xce, 0xd3, 0xf8,
	0x20, 0xf1, 0x71, 0x50, 0x6e, 0x55, 0xf0, 0x17, 0xc6, 0x6f, 0xfd, 0x1f, 0xb4, 0x32, 0x75, 0x6a,
	0x84, 0xc1, 0x1d, 0x2d, 0x9e, 0xf1, 0x88, 0x1d, 0x73, 0x1f, 0xbf, 0x62, 0xff, 0x72, 0x88, 0x87,
	0xf6, 0xc9, 0xab, 0x71, 0xed, 0xe5, 0xab, 0x71, 0xed, 0xe4, 0x74, 0x6c, 0xbd, 0x3c, 0x1d, 0x5b,
	0xbf, 0x9f, 0x8e, 0xad, 0x17, 0x7f, 0x8c, 0x6b, 0xbb, 0x6d, 0xfc, 0xfb, 0xbb, 0xf7, 0x77, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xfc, 0x8e, 0x80, 0x5f, 0x32, 0x0a, 0x00, 0x00,
}
